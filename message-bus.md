# Message Bus Plugin

The message bus plugin provides a WebSocket API endpoint that allows clients to asynchronously send and receive arbitrary events from other clients, or from the API itself (via other plugins)

## Overview

The message bus is designed to facilitate creating highly interactive client applications that can respond to any number of external events in a loosely-coupled fashion.  A client will connect to the WebSocket endpoint and be given a globally unique ID.  From this point, a client application will receive messages when other activities occur on the system.  Messages such as X11 server events, desktop notifications, and custom events generated by other clients will stream into the client for processing or to be ignored.

### Example 1: Message sent on successful connection to the bus
```json
{
  "id":        "aaaa1234-bbbb-cccc-dddd-123456789012",
  "timestamp": "1970-01-01T18:35:21.561321636-04:00",
  "type":      "connect"
}
```


## Control Messages

Clients can issue special messages called _Control Messages_ that will not be broadcast on the bus, but rather are used to modify the client's connection on the server.  Control messages can be used to get statistics about the connection, temporarily disable receiving messages, and select only certain messages.  All control messages require the `"type"`, `"id"` and `"verb"` fields in the request.

### Example 2: Sample Control Message and Reply

##### Request:
```json
{
  "type": "control",
  "id":   "aaaa1234-bbbb-cccc-dddd-123456789012",
  "verb": "activate"
}

```

##### Reply:
```json
{
  "timestamp": "1970-01-01T18:35:21.561321636-04:00",
  "type":      "succeeded",
  "message":   "Connection has been activated and will receive all messages destined for it"
}

```

Replies will have a type of either `"succeeded"` or `"failed"`, and optionally a `"message"` with more details.


## Tag Filters

By convention, the vast majority of events on the message bus will have one or more _tags_ associated with them.  Your client can register _filters_ with the server to select only a subset of messages that you are interested in.  The following rules describe how tags will behave.

* If the client's has _not_ set any filter tags, it will receive all messages.
* If the client has set filter tags, it will only receive messages whose tags are a subset of the client's filter.
* If the `"global"` field is `true` on a message, the client will receive that message regardless of filter status.

The table below illustrates how this works:

| Client Filter Tags                | Inbound Message Tags                 | Message Has `"global"` field set? | Client Receives Message  |
| --------------------------------- | ------------------------------------ | --------------------------------- | ------------------------ |
| []                                | []                                   | No                                | **Yes**                  |
| []                                | []                                   | Yes                               | **Yes**                  |
| []                                | ["test"]                             | No                                | **Yes**                  |
| ["test"]                          | ["test"]                             | No                                | **Yes**                  |
| ["test"]                          | ["other"]                            | No                                | No                       |
| ["test"]                          | ["other"]                            | Yes                               | **Yes**                  |
| ["test", "other"]                 | ["other"]                            | No                                | **Yes**                  |
| ["test", "other"]                 | ["other", "other2"]                  | No                                | No                       |
| ["test", "other"]                 | []                                   | No                                | **Yes**                  |

